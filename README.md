# Polar Coding for Interference Channels


## Introduction

5G communications presents a new paradigm in mobile communications, one that supports higher data rates and an order of magnitude more connected devices. Supporting all of these devices and higher rates requires more base stations that have shorter coverage radii. As a result, these base stations inevitably have more overlap, and have more opportunity for interference with other devices trying to reach the same base station.

Polar coding is a method of error-correcting codes that has been provably shown to reach channel capacity. Currently, the 5G standard only covers polar coding in the case of point-to-point communications for a specific AWGN channel model. This project attempts to use polar codes in an interference channel, as outlined by *[Polar Coding for Interference Networks](https://arxiv.org/pdf/1401.7293.pdf)* by Lele Wang and Eren Şaşoğlu.

The overall scope of the project is a comparison between three interference mitigation methods: Treating Interference as Noise (TIN), Successive Cancellation (SC) and Simultaneous Decoding (SD). The first two can already be implemented in existing point-to-point cases, but Simultaneous Decoding is a novel approach to the problem. 

## Current Progress

The current progress of the project has a few features already implemented, and some yet to be implemented. 

First, two different polar code construction algorithms have been implemented: one using Bhattacharrya parameters and another presented in *[How to Construct Polar Codes](https://arxiv.org/pdf/1105.6164.pdf)* by Ido Tal and Alexander Vardy.

Second, scripts to run simulations for both point-to-point and two-user interference channels.

Third, the typical polar coding encoder and decoder are implemented here as well.

Fourth, the Simultaneous Decoding method has been partially implemented. An encoder has been made, but the decoder is unfinished. Since the decoder is unfinished, the encoder is untested.

## Simultaneous Decoding

As explained before, the Simultaneous Decoding improves upon the achievable rate bounds of the other two methods. Consider the case of two transmitters and two receivers. Given a bit channel P<sub>i</sub> that originates from channel 1, this bit channel can either be perfectly noisy or perfectly noiseless in the polar coding scheme. However, if the two channel models (transmitter 1 to receiver 1 and transmitter 1 to receiver 2) are different, this means that the bit channels will be polarized in different ways. In this case, bit channel P<sub>i</sub> may be perfectly noiseless in one channel and completely noisy in another channel. For the other decoding methods, we would have to consider this given channel as noisy.

However, we can align pairs of these bit channels such that we reduce the number of bit channels that are noisy in one channel and noiseless in the other. We align these channels recursively using a modulo-2 addition, similar to the regular polar coding scheme. After alignment, we rearrange the indices such that it is in decoding order as to preserve successive decodability. 

More details can be found in the paper previously linked in the introduction.

## Implementation details
Here I'll describe some of the relevant functions found in the repository. 

### Code Construction
 - bhattacharrya_bounds.m
	 - Outputs the frozen bits based on the Bhattacharrya parameter. 
 - get_frozen_bits_interference.m
	 - Given a target SNR (dB), interference paramter g and block length N, it outputs the probability of error for each bit index based on the Tal and Vardy algorithm.
 - code_constructions folder
	 - A folder of pre-calculated probability of errors, generated by the Tal and Vardy algorithm. The Tal and Vardy algorithm is generally pretty slow, so this speeds up any simulation that requires the frozen bits.
	 - Files for N = 2048/32768, g = 0.1/0.5/0.9, SNR = 3dB/5dB. 
	 - Ready to use as with readmatrix(file_name).
### Simulation Scripts
- achievable_rate_test.m 
	- Outputs a plot of the achievable rate region for TIN or SC (can be easily changed) based on the bit error rate estimation.
	- Runs a sweep of different code rates and different interference strengths. 
- interference_test.m
	- Outputs a BER vs interference strength plot for different equal code rates. 
	- Can be adapted for TIN or SC.
- point2point_pc.m 
	- Runs a point-to-point simulation for polar codes, plots a BER vs SNR curve. 
### Polar Encoder and Decoder
- pc_encoder.m
	- The polar encoder which takes in the block length N, the original message and the frozen indices
- pc_decoder.m
	- Recursive polar decoder, the preferred decoder.
- pc_decoder2.m
	- Another recursive polar decoder based on LLR's, slower than the other polar decoder

### Simultaneous Decoding
- get_aligned_structure.m
	- Give the type 2 and type 3 indices, the block length, the number of blocks and the number of recursions, this function returns the decoding reordering, the encoding ordering and the incompatible indices at each recursion.
	- Each row of the outputs is the rearranging block at that given recursion, or it is the incompatible indices at the given recursion.
- get_full_decoding_order.m
	- Given the decoding orders and the incompatible indices at each recursion, this function returns the complete decoding order after all of the recursions, as well as the aligned indices after rearranging. 
	- Will be used in the decoding to determine which indices are combined with each other.
- full_dec_order.m
	- A test for the other functions that shows the decoding order and the combined indices.
- align_incompatible.m
	- The encoder for the SD algorithm, given the message u, incompatible indices at each recursion, the encoding orders at each recursion, the block size and the number of recursions, it outputs the aligned message u that can then be put through the polar encoder.
